{"version":3,"file":"togeojson.umd.js","sources":["../lib/shared.js","../lib/gpx.js","../lib/tcx.js","../lib/kml.js"],"sourcesContent":["// cast array x into numbers\n// get the content of a text node, if any\nexport function nodeVal(x) {\n  if (x && x.normalize) {\n    x.normalize();\n  }\n  return (x && x.textContent) || \"\";\n}\n\n// one Y child of X, if any, otherwise null\nexport function get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}","import { nodeVal, get1 } from \"./shared.js\";\n\nfunction getLineStyle(extensions) {\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\")),\n        opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\"))),\n        width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\nfunction getExtensions(node) {\n  let values = [];\n  if (node !== null) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      const child = node.childNodes[i];\n      if (child.nodeType !== 1) continue;\n      const name = [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(child.nodeName)\n        ? \"heart\"\n        : child.nodeName;\n      if (name === \"gpxtpx:TrackPointExtension\") {\n        // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n        values = values.concat(getExtensions(child));\n      } else {\n        // push custom extension (eg. \"power\")\n        const val = nodeVal(child);\n        values.push([name, isNaN(val) ? val : parseFloat(val)]);\n      }\n    }\n  }\n  return values;\n}\n\nfunction getMulti(x, ys) {\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n);\n  }\n  return o;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  // Parse additional data from our Garmin extension(s)\n  const extensions = node.getElementsByTagNameNS(\n    \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n    \"*\"\n  );\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    // Ignore nested extensions, like those on routepoints or trackpoints\n    if (extension.parentNode.parentNode === node) {\n      prop[extension.tagName.replace(\":\", \"_\")] = nodeVal(extension);\n    }\n  }\n  const links = node.getElementsByTagName(\"link\");\n  if (links.length) prop.links = [];\n  for (let i = 0; i < links.length; i++) {\n    prop.links.push(\n      Object.assign(\n        { href: links[i].getAttribute(\"href\") },\n        getMulti(links[i], [\"text\", \"type\"])\n      )\n    );\n  }\n  return prop;\n}\n\nfunction coordPair(x) {\n  const ll = [\n    parseFloat(x.getAttribute(\"lon\")),\n    parseFloat(x.getAttribute(\"lat\")),\n  ];\n  const ele = get1(x, \"ele\");\n  const time = get1(x, \"time\");\n  if (ele) {\n    const e = parseFloat(nodeVal(ele));\n    if (!isNaN(e)) {\n      ll.push(e);\n    }\n  }\n\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(x, \"extensions\")),\n  };\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      getProperties(node),\n      getLineStyle(get1(node, \"extensions\")),\n      { _gpxType: \"rte\" }\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  if (pts.length < 2) return; // Invalid line in GeoJSON\n\n  const line = [];\n  const times = [];\n  const extendedValues = {};\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (let j = 0; j < c.extendedValues.length; j++) {\n      const [name, val] = c.extendedValues[j];\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\nfunction getTrack(node) {\n  const segments = node.getElementsByTagName(\"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    const line = getPoints(segments[i], \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return;\n\n  const multi = extractedLines.length > 1;\n\n  const properties = Object.assign(\n    getProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    { _gpxType: \"trk\" },\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (let i = 0; i < extractedLines.length; i++) {\n    const line = extractedLines[i];\n    track.push(line.line);\n    for (const [name, val] of Object.entries(line.extendedValues)) {\n      if (!properties.coordinateProperties) {\n        properties.coordinateProperties = {};\n      }\n      const props = properties.coordinateProperties;\n      if (multi) {\n        if (!props[name])\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\nfunction getPoint(node) {\n  return {\n    type: \"Feature\",\n    properties: Object.assign(getProperties(node), getMulti(node, [\"sym\"])),\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates,\n    },\n  };\n}\n\nexport function* gpxGen(doc) {\n  const tracks = doc.getElementsByTagName(\"trk\");\n  const routes = doc.getElementsByTagName(\"rte\");\n  const waypoints = doc.getElementsByTagName(\"wpt\");\n\n  for (let i = 0; i < tracks.length; i++) {\n    const feature = getTrack(tracks[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < routes.length; i++) {\n    const feature = getRoute(routes[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < waypoints.length; i++) {\n    yield getPoint(waypoints[i]);\n  }\n}\n\nexport function gpx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(doc)),\n  };\n}\n","import { nodeVal, get1 } from \"./shared.js\";\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction fromEntries(arr) {\n  const obj = {};\n  for (const [key, value] of arr) {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction getProperties(node, attributeNames) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(x) {\n  const lon = nodeVal(get1(x, \"LongitudeDegrees\"));\n  const lat = nodeVal(get1(x, \"LatitudeDegrees\"));\n  if (!lon.length || !lat.length) {\n    return null;\n  }\n  const ll = [parseFloat(lon), parseFloat(lat)];\n  const alt = get1(x, \"AltitudeMeters\");\n  const heartRate = get1(x, \"HeartRateBpm\");\n  const time = get1(x, \"Time\");\n  let a;\n  if (alt) {\n    a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(x, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  const line = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const result = { extendedProperties: {} };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    if (c.heartRate) heartRates.push(c.heartRate);\n    for (const [alias, value] of c.extensions) {\n      if (!result.extendedProperties[alias]) {\n        result.extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      result.extendedProperties[alias][i] = value;\n    }\n  }\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node) {\n  const segments = node.getElementsByTagName(\"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties = fromEntries(getProperties(node, LAP_ATTRIBUTES));\n\n  const nameElement = get1(node, \"Name\");\n  if (nameElement) {\n    properties.name = nodeVal(nameElement);\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"Trackpoint\");\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        properties[property] = line.extendedProperties[property];\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n  if (track.length === 0) return;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: {\n      type: track.length === 1 ? \"LineString\" : \"MultiLineString\",\n      coordinates: track.length === 1 ? track[0] : track,\n    },\n  };\n}\n\nexport function* tcxGen(doc) {\n  const laps = doc.getElementsByTagName(\"Lap\");\n\n  for (let i = 0; i < laps.length; i++) {\n    const feature = getLap(laps[i]);\n    if (feature) yield feature;\n  }\n\n  const courses = doc.getElementsByTagName(\"Courses\");\n\n  for (let i = 0; i < courses.length; i++) {\n    const feature = getLap(courses[i]);\n    if (feature) yield feature;\n  }\n}\n\nexport function tcx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(doc)),\n  };\n}\n","import { nodeVal, get1 } from \"./shared.js\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n// generate a short, numeric hash of a string\nfunction okhash(x) {\n  if (!x || !x.length) return 0;\n  let h = 0;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v) {\n  return v.replace(removeSpace, \"\").split(\",\").map(parseFloat);\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v) {\n  return v.replace(trimSpace, \"\").split(splitSpace).map(coord1);\n}\n\nfunction xml2str(node) {\n  if (node.xml !== undefined) return node.xml;\n  if (node.tagName) {\n    let output = node.tagName;\n    for (let i = 0; i < node.attributes.length; i++) {\n      output += node.attributes[i].name + node.attributes[i].value;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      output += xml2str(node.childNodes[i]);\n    }\n    return output;\n  }\n  if (node.nodeName === \"#text\") {\n    return (node.nodeValue || node.value || \"\").trim();\n  }\n  if (node.nodeName === \"#cdata-section\") {\n    return node.nodeValue;\n  }\n  return \"\";\n}\n\nconst geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n\nfunction kmlColor(properties, elem, prefix) {\n  let v = nodeVal(get1(elem, \"color\")) || \"\";\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v.substr(0, 1) === \"#\") {\n    v = v.substr(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substr(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);\n  }\n}\n\nfunction numericProperty(properties, elem, source, target) {\n  const val = parseFloat(nodeVal(get1(elem, source)));\n  if (!isNaN(val)) properties[target] = val;\n}\n\nfunction gxCoords(root) {\n  let elems = root.getElementsByTagName(\"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = root.getElementsByTagName(\"gx:coord\");\n  for (let i = 0; i < elems.length; i++) {\n    coords.push(nodeVal(elems[i]).split(\" \").map(parseFloat));\n  }\n  const timeElems = root.getElementsByTagName(\"when\");\n  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n  return {\n    coords: coords,\n    times: times,\n  };\n}\n\nfunction getGeometry(root) {\n  let geomNode;\n  let geomNodes;\n  let i;\n  let j;\n  let k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\")) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\")) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\")) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = root.getElementsByTagName(geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = geomNode.getElementsByTagName(\"LinearRing\"),\n            coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\"))));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms: geoms,\n    coordTimes: coordTimes,\n  };\n}\n\nfunction getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {\n  const geomsAndTimes = getGeometry(root);\n  let i;\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  let iconStyle = get1(root, \"IconStyle\");\n  let labelStyle = get1(root, \"LabelStyle\");\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  const visibility = get1(root, \"visibility\");\n\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") {\n      styleUrl = \"#\" + styleUrl;\n    }\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash];\n    if (style) {\n      if (!iconStyle) iconStyle = get1(style, \"IconStyle\");\n      if (!labelStyle) labelStyle = get1(style, \"LabelStyle\");\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    properties.timespan = { begin: begin, end: end };\n  }\n  if (timeStamp) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\"));\n  }\n  if (iconStyle) {\n    kmlColor(properties, iconStyle, \"icon\");\n    numericProperty(properties, iconStyle, \"scale\", \"icon-scale\");\n    numericProperty(properties, iconStyle, \"heading\", \"icon-heading\");\n\n    const hotspot = get1(iconStyle, \"hotSpot\");\n    if (hotspot) {\n      const left = parseFloat(hotspot.getAttribute(\"x\"));\n      const top = parseFloat(hotspot.getAttribute(\"y\"));\n      if (!isNaN(left) && !isNaN(top)) properties[\"icon-offset\"] = [left, top];\n    }\n    const icon = get1(iconStyle, \"Icon\");\n    if (icon) {\n      const href = nodeVal(get1(icon, \"href\"));\n      if (href) properties.icon = href;\n    }\n  }\n  if (labelStyle) {\n    kmlColor(properties, labelStyle, \"label\");\n    numericProperty(properties, labelStyle, \"scale\", \"label-scale\");\n  }\n  if (lineStyle) {\n    kmlColor(properties, lineStyle, \"stroke\");\n    numericProperty(properties, lineStyle, \"width\", \"stroke-width\");\n  }\n  if (polyStyle) {\n    kmlColor(properties, polyStyle, \"fill\");\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = extendedData.getElementsByTagName(\"Data\"),\n      simpleDatas = extendedData.getElementsByTagName(\"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\")] = nodeVal(\n        get1(datas[i], \"value\")\n      );\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\")] = nodeVal(simpleDatas[i]);\n    }\n  }\n  if (visibility) {\n    properties.visibility = nodeVal(visibility);\n  }\n  if (geomsAndTimes.coordTimes.length) {\n    properties.coordinateProperties = {\n      times:\n        geomsAndTimes.coordTimes.length === 1\n          ? geomsAndTimes.coordTimes[0]\n          : geomsAndTimes.coordTimes,\n    };\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 0\n        ? null\n        : geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (root.getAttribute(\"id\")) feature.id = root.getAttribute(\"id\");\n  return feature;\n}\n\nexport function* kmlGen(doc) {\n  // styleindex keeps track of hashed styles in order to match feature\n  const styleIndex = {};\n  const styleByHash = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex = {};\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = doc.getElementsByTagName(\"Placemark\");\n  const styles = doc.getElementsByTagName(\"Style\");\n  const styleMaps = doc.getElementsByTagName(\"StyleMap\");\n\n  for (let k = 0; k < styles.length; k++) {\n    const style = styles[k];\n    const hash = okhash(xml2str(style)).toString(16);\n    let id = style.getAttribute(\"id\");\n    if (\n      !id &&\n      style.parentNode.tagName.replace(\"gx:\", \"\") === \"CascadingStyle\"\n    ) {\n      id =\n        style.parentNode.getAttribute(\"kml:id\") ||\n        style.parentNode.getAttribute(\"id\");\n    }\n    styleIndex[\"#\" + id] = hash;\n    styleByHash[hash] = style;\n  }\n  for (let l = 0; l < styleMaps.length; l++) {\n    styleIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = okhash(\n      xml2str(styleMaps[l])\n    ).toString(16);\n    const pairs = styleMaps[l].getElementsByTagName(\"Pair\");\n    const pairsMap = {};\n    for (let m = 0; m < pairs.length; m++) {\n      pairsMap[nodeVal(get1(pairs[m], \"key\"))] = nodeVal(\n        get1(pairs[m], \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = pairsMap;\n  }\n  for (let j = 0; j < placemarks.length; j++) {\n    const feature = getPlacemark(\n      placemarks[j],\n      styleIndex,\n      styleMapIndex,\n      styleByHash\n    );\n    if (feature) yield feature;\n  }\n}\n\nexport function kml(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(doc)),\n  };\n}\n"],"names":["nodeVal","x","normalize","textContent","get1","y","n","getElementsByTagName","length","getLineStyle","extensions","style","lineStyle","color","opacity","parseFloat","width","stroke","isNaN","getExtensions","node","values","i","childNodes","child","nodeType","name","includes","nodeName","concat","val","push","getMulti","ys","o","k","getProperties","prop","getElementsByTagNameNS","extension","parentNode","tagName","replace","links","Object","assign","href","getAttribute","coordPair","ll","ele","time","e","coordinates","extendedValues","getRoute","line","getPoints","type","properties","_gpxType","geometry","pointname","pts","times","c","j","plural","Array","fill","getTrack","segments","track","extractedLines","multi","coordinateProperties","entries","props","map","gpxGen","doc","tracks","routes","waypoints","feature","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","attributeNames","tag","alias","elem","elements","lon","lat","alt","heartRate","a","heartRates","result","extendedProperties","value","getLap","allExtendedProperties","arr","obj","key","fromEntries","nameElement","property","heart","tcxGen","laps","courses","removeSpace","trimSpace","splitSpace","okhash","h","charCodeAt","coord1","v","split","coord","xml2str","undefined","xml","output","attributes","nodeValue","trim","geotypes","kmlColor","prefix","colorProp","substr","parseInt","numericProperty","source","target","gxCoords","root","elems","coords","timeElems","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","getPlacemark","styleIndex","styleMapIndex","styleByHash","geomsAndTimes","address","styleUrl","description","timeSpan","timeStamp","extendedData","iconStyle","labelStyle","polyStyle","visibility","styleHash","styleMapHash","normal","begin","end","timespan","timestamp","hotspot","left","top","icon","outline","datas","simpleDatas","geometries","id","kmlGen","placemarks","styles","styleMaps","hash","toString","l","pairs","pairsMap","m","features","from"],"mappings":"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"}