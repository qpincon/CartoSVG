<!-- https://observablehq.com/@jjhembd/tilting-the-satellite -->
<!DOCTYPE html>
<meta charset="utf-8">

<body>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
<div id="container"></div>


<script>
    const pane = new Tweakpane.Pane();
    const params = {
        longitude: 15,
        latitude: 36,
        altitude: 1000,
        rotation: 0,
        tilt: 25,
        fieldOfView: 50,
        useCanvas: false,
        innerGlowParams: {blur: 4, strength: 1.4, color: "#7c490eff"},
        outerGlowParams: {blur: 4, strength: 3, color: '#ffffffff'},
        useGraticule: true,
        graticuleStep: 3,
        bgColor: "#ddfdff66",
        hoverColor: "#fbbc0023",
        bgNoise: true,
    };
    const bounds = {
        longitude: [-180, 180],
        latitude: [-90, 90],
        rotation: [-180, 180],
        tilt: [0, 90],
        altitude: [8, 32000],
        fieldOfView: [1, 180],
        blur: [0.5, 10],
        strength: [0.1, 10],
        graticuleStep: [0.1, 10]
    }
    let width = 1800;
    const numPixelsY = width * 0.6;
    const earthRadius = 6371;
    const degrees = 180 / Math.PI;
    let timeoutId;
    function gui(opts, redraw) {
        const pane = new Tweakpane.Pane({title: 'Options', expanded: false});
        Object.entries(params).forEach(([key, value]) => {
            add(opts, key, value);
        })

        function add(opts, key, value, folder = pane) {
            if (typeof value == 'object') {
                const group = pane.addFolder({title: key, expanded: false});
                Object.entries(value).forEach(([innerKey, innerValue]) => {
                    add(value, innerKey, innerValue, group);
                });
            } else {
                let params = {};
                const boundsDef = bounds[key];
                if (boundsDef) {
                    params = {min: boundsDef[0], max:boundsDef[1]}
                }
                folder.addInput(opts, key, params);
            }
        }
        pane.on('change', () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                redraw();
            }, 300);
        });
    }
    if (typeof gui == 'function') {
        gui(params, draw);
    }

    function appendGlow(id="glows", 
                        innerParams = {blur: 2, strength: 1, color: "#7c490e"},
                        outerParams = {blur: 4, strength: 1, color: '#998'}) {
        const colorInner = d3.rgb(innerParams.color);
        const colorOuter = d3.rgb(outerParams.color);
        const existing = d3.select(`#${id}`);
        const defs = !existing.empty() ? existing.select(function() { return this.parentNode} ) : d3.select('body')
            .append('svg')
                .attr('width', 0)
                .attr('height', 0)
                .append('defs');
        if (!existing.empty()) existing.remove();
        const filter = defs.append('filter').attr('id', id);

        // OUTER GLOW
        filter.append('feMorphology')
            .attr('in', 'SourceGraphic')
            .attr('radius', outerParams.strength)
            .attr('operator', 'dilate')
            .attr('result', 'MASK_OUTER');
        filter.append('feColorMatrix')
            .attr('in', 'MASK_OUTER')
            .attr('type', 'matrix')
            .attr('values', `0 0 0 0 ${colorOuter.r / 255} 0 0 0 0 ${colorOuter.g / 255} 0 0 0 0 ${colorOuter.b / 255} 0 0 0 ${colorOuter.opacity} 0`) // apply color
            .attr('result', 'OUTER_COLORED');
        filter.append('feGaussianBlur')
            .attr('in', 'OUTER_COLORED')
            .attr('stdDeviation', outerParams.blur)
            .attr('result', 'OUTER_BLUR');
        filter.append('feComposite')
            .attr('in', 'OUTER_BLUR')
            .attr('in2', 'SourceGraphic')
            .attr('operator', 'out')
            .attr('result', 'OUTGLOW');

        // INNER GLOW
        filter.append('feMorphology')
            .attr('in', 'SourceAlpha')
            .attr('radius', innerParams.strength)
            .attr('operator', 'erode')
            .attr('result', 'INNER_ERODED');

        filter.append('feGaussianBlur')
            .attr('in', 'INNER_ERODED')
            .attr('stdDeviation', innerParams.blur)
            .attr('result', 'INNER_BLURRED');

        filter.append('feColorMatrix')
            .attr('in', 'INNER_BLURRED')
            .attr('type', 'matrix')
            .attr('values', `0 0 0 0 ${colorInner.r / 255} 0 0 0 0 ${colorInner.g / 255} 0 0 0 0 ${colorInner.b / 255} 0 0 0 -1 1`) // inverse color
            .attr('result', 'INNER_COLOR');

        filter.append('feComposite')
            .attr('in', 'INNER_COLOR')
            .attr('in2', 'SourceGraphic')
            .attr('operator', 'in')
            .attr('result', 'INGLOW');

        // Merge
        const merge = filter.append('feMerge');
        merge.append('feMergeNode').attr('in', 'OUTGLOW');
        merge.append('feMergeNode').attr('in', 'SourceGraphic');
        merge.append('feMergeNode').attr('in', 'INGLOW');
        filter.append(() => merge.node());
        defs.append(() => filter.node());
    }

    let countries = null;
    let land = null
    // fetch("https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json")
    // fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/land-10m.json")
    fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-10m.json")
        .then(response => response.json())
        // .then(world => topojson.merge(world, world.objects.countries.geometries.filter(feat => feat.id !== '462'))) // remove buggy maldives
        // .then(world => topojson.feature(world, world.objects.countries))
        // .then(world => topojson.feature(world, world.objects.land))
        .then(world => {
            world.objects.countries.geometries = world.objects.countries.geometries.filter(feat => feat.id !== '462');
            const merged = topojson.merge(world, world.objects.countries.geometries);
            land = merged;
            countries = topojson.feature(world, world.objects.countries);
            console.log(land);
            draw();
        });

    function draw() {
        const snyderP = 1.0 + params.altitude / earthRadius;
        const dY = params.altitude * Math.sin(params.tilt / degrees);
        const dZ = params.altitude * Math.cos(params.tilt / degrees);
        const visibleYextent = 2 * dZ * Math.tan(0.5 * params.fieldOfView / degrees);
        const yShift = dY * numPixelsY / visibleYextent;
        const scale = earthRadius * numPixelsY / visibleYextent;
        const tilt = params.tilt / degrees;
        const alpha = Math.acos(snyderP * Math.cos(tilt) * 0.999);
        const clipDistance = d3.geoClipCircle(Math.acos(1 / snyderP) - 1e-6);
        const preclip = alpha ? geoPipeline(
            clipDistance,
            geoRotatePhi(Math.PI + tilt),
            d3.geoClipCircle(Math.PI - alpha - 1e-4), // Extra safety factor needed for large tilt values
            geoRotatePhi(-Math.PI - tilt)
        ) : clipDistance;

        function geoRotatePhi(deltaPhi) {
            const cosDeltaPhi = Math.cos(deltaPhi);
            const sinDeltaPhi = Math.sin(deltaPhi);
            return sink => ({
                point(lambda, phi) {
                    const cosPhi = Math.cos(phi);
                    const x = Math.cos(lambda) * cosPhi;
                    const y = Math.sin(lambda) * cosPhi;
                    const z = Math.sin(phi);
                    const k = z * cosDeltaPhi + x * sinDeltaPhi;
                    sink.point(Math.atan2(y, x * cosDeltaPhi - z * sinDeltaPhi), Math.asin(k));
                },
                lineStart() { sink.lineStart(); },
                lineEnd() { sink.lineEnd(); },
                polygonStart() { sink.polygonStart(); },
                polygonEnd() { sink.polygonEnd(); },
                sphere() { sink.sphere(); }
            });
        }

        function geoPipeline(...transforms) {
            return sink => {
                for (let i = transforms.length - 1; i >= 0; --i) {
                    sink = transforms[i](sink);
                }
                return sink;
            };
        }

        const projection = d3.geoSatellite()
            .scale(scale)
            .translate([width / 2, yShift + numPixelsY / 2])
            .rotate([-params.longitude, -params.latitude, params.rotation])
            .tilt(params.tilt)
            .distance(snyderP)
            .preclip(preclip)
            .precision(0.1);

        const container = d3.select('#container');
        container.html('');
        const graticule = d3.geoGraticule().step([params.graticuleStep, params.graticuleStep]);
        if (params.useCanvas) {
            let canvas = container.select('#canvas');
            if (canvas.empty()) canvas = container.append('canvas').attr('id', 'canvas').attr('width', width).attr('height', numPixelsY);
            const context = canvas.node().getContext('2d');
            context.clearRect(0, 0, width, numPixelsY);
            const path = d3.geoPath(projection, context);
            context.fillStyle = "#88d";
            context.beginPath(), path(land), context.fill();
            context.beginPath(),
                path(graticule),
                (context.strokeStyle = "#ddf"),
                (context.globalAlpha = 0.8),
                context.stroke();
            return context.canvas;
        }
        let svg = container.select('svg');
        if (svg.empty()) svg = container.append('svg')
            .attr('viewBox', `0 0 ${width} ${numPixelsY}`)
            .attr('id', 'map');
        const path = d3.geoPath(projection);
        svg.html('');
        svg.on("click", function(e) {
            console.log(projection.invert(d3.pointer(e)));
        });
        
        const groupData = [
            { name: 'land', data: [land], id: null, props: [], class: 'land', filters: ['glows'] },
            { name: 'countries', data: countries, id: { prefix: 'iso-3166-1-', field: 'id' }, props: ['name'], class: 'country', filters: [] },
        ];
        if (params.useGraticule) {
            groupData.splice(0, 0, { name: 'graticule', data: [graticule()], id: null, props: [], class: 'graticule', filters:[] });
        }

        const groups = svg.selectAll('g').data(groupData).join('g').attr('id', d => d.name);

        function drawPaths(data) {
            const pathElem = d3.select(this).selectAll('path')
                // .data(data.data)
                .data(data.data.features ? data.data.features : data.data)
                .join('path')
                .attr('d', (d) => path(d));
            if (data.id) pathElem.attr('id', (d) => data.id.prefix + d[data.id.field]);
            if (data.class) pathElem.attr('class', data.class);
            if (data.filters.length) {
                const filters = data.filters.map(f => `url(#${f})`).join(' ');
                pathElem.attr('filter', filters);
            }
            data.props.forEach((prop) => pathElem.attr(prop, (d) => d.properties[prop]))
        }

        groups.each(drawPaths);
        // removeNotVisible();
        appendGlow('glows', params.innerGlowParams, params.outerGlowParams);
        const map = d3.select('#map')
            .style('--bg-color', params.bgColor)
            .style('--country-hover-color', params.hoverColor)
            .style('background-image', params.bgNoise ? "url('./bg.png')" : 'none');
    }

    function removeNotVisible() {
        const countries = document.getElementById('countries');
        const paths = Array.from(countries.children);
        const map = document.getElementById('map');
        const svgBounds = map.getBoundingClientRect();
        console.log('Number of paths before:', paths.length);
        paths.forEach(p => {
            const rect = p.getBoundingClientRect();
            if (rect.width == 0 && rect.height == 0) p.remove();
        });
        console.log('Number of paths after:', Array.from(countries.children).length);
    }

</script>

<style>
    :root {
        --bg-color: #ddfdff66; 
        --country-hover-color: #ffe1cc8e;
    }

    #map {
        background-image: url('./bg.png');
        background-repeat: repeat;
        background-color: var(--bg-color);
    }
    .graticule {
        fill: none;
        stroke: #777;
        stroke-width: .5px;
        stroke-opacity: .5;
    }
    .land {
        stroke-opacity: 0;
        fill: #ffffff;
        fill-opacity: 1;
    }
    .country {
        stroke: #D1BEB0;
        stroke-opacity: .3;
        fill: #ffffff67;
        fill-opacity: 1;
    }
    .country:hover {
        fill: var(--country-hover-color);
    }

</style>